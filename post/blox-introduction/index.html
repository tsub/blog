
<!DOCTYPE html>
<html lang="ja">
<head>

  
  <meta charset="UTF-8">
  <title>
    Blox Introduction | tsub&#39;s blog
  </title>


  
  <meta name="viewport" content="width=device-width,user-scalable=no,maximum-scale=1,initial-scale=1">

  
  <link rel="canonical" href="https://blog.tsub.me/post/blox-introduction/"/>

  
  <link rel="stylesheet" href="/css/sanitize.css">
  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/highlight_monokai.css">
  <link rel="stylesheet" href="/css/theme.css">
  <link rel="stylesheet" href="/css/custom.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  
  
  <link href="https://blog.tsub.me/index.xml" rel="alternate" type="application/rss+xml" title="tsub&#39;s blog" />
  <link href="https://blog.tsub.me/index.xml" rel="feed" type="application/rss+xml" title="tsub&#39;s blog" />

  
  

  
   
    
  
    <meta name="twitter:card" content="summary"/>
    
      <meta name="twitter:image" content="https://blog.tsub.me/images/profile.jpg" />
    
  

  
  <meta name="twitter:title" content="Blox Introduction"/>
  <meta name="twitter:description" content="この記事はDocker Advent Calendar 2016の9日目の記事です。

先日AWSのre:Invent 2016でBloxが発表されました。

BloxはEC2 Container Service(ECS)関連のオープンソースのツール群のことです。

そしてそのツールとは主にECSのカスタムスケジューラを指します

ECSはマネージドなスケジューラとマネージャを標準で備えていますが、Bloxはそれとは別に自分でホスティングする必要があります。

しかし、ECSに足りない機能を補ってくれるため導入するメリットは大きいでしょう。

先日リリースされた、CloudWatchEventsのECSイベントストリームを利用することで、よりスムーズにECSのクラスタの状態を監視してカスタムスケジューラを作ることができるようになりました。

Bloxはこれを使った一例と言えます

この記事ではBloxについて試してみて分かった内容や所感について書いていきます



"/>

  
    <meta name="twitter:site" content="@_tsub_"/>
  

  

  
  
    <meta name="twitter:creator" content="@tsub"/>
  


  


</head>



<body>
<div class="container">

  
  <header role="banner">
    <div class="row gutters">
      <div id="site-title" class="col span_6">
        <h1><a href="https://blog.tsub.me/">tsub&#39;s blog</a></h1>
        <h2>雑なメモ</h2>
      </div>
      <div id="social" class="col span_6">
        <ul>
          <li><a href="https://twitter.com/_tsub_" target="_blank"><i class="fa fa-twitter"></i> Twitter</a></li>
          
          <li><a href="https://github.com/tsub" target="_blank"><i class="fa fa-github"></i> GitHub</a></li>
          <li><a href="https://blog.tsub.me/index.xml" type="application/rss+xml" target="_blank"><i class="fa fa-rss"></i> RSS</a></li>
        </ul>
      </div>
    </div>
  </header>


  
  <main id="single" role="main">
    <div class="article-header">
      <h1>Blox Introduction</h1>
      <div class="meta">
        Dec 9, 2016 &nbsp;
        
          <a href="/tags/blox">#Blox</a>&nbsp;
        
          <a href="/tags/ecs">#ECS</a>&nbsp;
        
          <a href="/tags/docker">#docker</a>&nbsp;
        
          <a href="/tags/aws">#AWS</a>&nbsp;
        
      </div>
    </div>
    <article>
      <p>この記事は<a href="http://qiita.com/advent-calendar/2016/docker">Docker Advent Calendar 2016</a>の9日目の記事です。</p>

<p>先日AWSのre:Invent 2016で<a href="https://blox.github.io/">Blox</a>が発表されました。</p>

<p>BloxはEC2 Container Service(ECS)関連のオープンソースのツール群のことです。</p>

<p>そしてそのツールとは主にECSのカスタムスケジューラを指します</p>

<p>ECSはマネージドなスケジューラとマネージャを標準で備えていますが、Bloxはそれとは別に自分でホスティングする必要があります。</p>

<p>しかし、ECSに足りない機能を補ってくれるため導入するメリットは大きいでしょう。</p>

<p><a href="https://aws.amazon.com/jp/blogs/news/monitor-cluster-state-with-amazon-ecs-event-stream/">先日リリースされた、CloudWatchEventsのECSイベントストリーム</a>を利用することで、よりスムーズにECSのクラスタの状態を監視してカスタムスケジューラを作ることができるようになりました。</p>

<p>Bloxはこれを使った一例と言えます</p>

<p>この記事ではBloxについて試してみて分かった内容や所感について書いていきます</p>

<p><img src="https://i.gyazo.com/4c00e85fca7b228d7aa0d5f1e6dd1d27.png" alt="Blox thumbnail" /></p>

<p></p>

<h2 id="bloxの主な機能">Bloxの主な機能</h2>

<p>Bloxが提供している機能は現在以下の2つです</p>

<ul>
<li>cluster-state-service</li>
<li>daemon-scheduler</li>
</ul>

<p>これらの機能をREST APIで扱うことができます。</p>

<p>どのような仕組みで動いているのかはAWS公式ブログにて分かりやすい図が載っていますのでまずは<a href="https://aws.amazon.com/jp/blogs/compute/introducing-blox-from-amazon-ec2-container-service/">こちら</a>を読むことをおすすめします</p>

<p>この記事ではその辺りには特に触れません。主に使い方などをまとめました。</p>

<p>今後の追加機能に関しては<a href="https://github.com/blox/blox/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20label%3A%22roadmap%22">ロードマップ</a>が作られていますのでそちらを参照してください</p>

<p>それではそれぞれの機能について見ていきます</p>

<h2 id="cluster-state-service">cluster-state-service</h2>

<h3 id="ecsの課題">ECSの課題</h3>

<p>ECSには様々なAPIが用意されており、コンテナインスタンスやタスクの情報などを取得することができます。</p>

<p>しかし、痒いところには手が届きません。</p>

<p>例えば、あるクラスタで動いている特定のタスクの一覧を取得したいときにECSのAPIだとあるクラスタで動いているタスクの一覧を取得し、そこから取得したいタスクをフィルタリングする&hellip;のような手順が必要で面倒です。</p>

<h3 id="cluster-state-serviceが提供するもの">cluster-state-serviceが提供するもの</h3>

<p>cluster-state-serviceはECSクラスタの状態を取得するためのものです。</p>

<p>冒頭でも書いたように、CloudWatchEventsのECSイベントストリームを利用できるようになりましたが、ECSのAPIからはそれらの情報は取得できません。</p>

<p>cluster-state-serviceはこのECSイベントストリームの情報を内部に保存し、外から参照できるREST APIを提供します。</p>

<p>cluster-state-serviceに関しては私はあまり理解できていませんが、クラスタ内の状態をより詳細に取得するための扱いやすいAPIというイメージです。</p>

<p>今のところGETするAPIしか提供していませんが、今後ECSのクラスタの状態を変更するためのAPIなども提供されるかもしれません。</p>

<p>また、後述のdaemon-schedulerでも内部的にcluster-state-serviceを使っているようです。</p>

<h3 id="apiドキュメント">APIドキュメント</h3>

<p>APIのエンドポイントは特にドキュメントがなかったのでswaggerから読む必要があります。</p>

<p><a href="https://github.com/go-swagger/go-swagger">go-swagger</a>を使ってブラウザで表示すると読みやすいと思います</p>

<p>以下の場所に<code>swagger.json</code>が置いてあります</p>

<pre><code class="language-sh">$ swagger serve cluster-state-service/handler/api/v1/swagger/swagger.json
</code></pre>

<h2 id="daemon-scheduler">daemon-scheduler</h2>

<h3 id="ecsの課題-1">ECSの課題</h3>

<p>ECSにはサービスという概念があります。</p>

<p>常駐しておきたいコンテナ群(タスク)をサービスとして動かすことで、希望するタスクの数をクラスタ内で一定に保つことができます。</p>

<p>これは非常に便利なのですが、クラスタ内の全コンテナインスタンスに対して1つずつタスクを実行させたい場合は使うことができません。</p>

<p>ポートを静的に指定すれば1コンテナインスタンスに1つずつタスクが実行されるのですが、「コンテナインスタンスの数 = タスクの数」を常に維持しなければいけないため、標準機能だけではできません。</p>

<p>また、ポートを静的に指定するというところもナンセンスです</p>

<h3 id="daemon-schedulerが提供するもの">daemon-schedulerが提供するもの</h3>

<p>daemon-schedulerはクラスタ内の全コンテナインスタンスに対して1つずつデーモンタスクを実行させるためのものです</p>

<p>例えば、dd-agentのような監視用コンテナを動かしたい場合、今まではUserdataを使ってインスタンスが立ち上がったタイミングで自分自身に対してECSのStartTaskを実行していましたが、daemon-schedulerを使えばその必要はなくなります。</p>

<p>クラスタ内に新たにコンテナインスタンスが立った場合、daemon-schedulerに設定しておいたTaskDefinitionを新たなコンテナインスタンスに対して勝手に実行してくれます。</p>

<h3 id="apiドキュメント-1">APIドキュメント</h3>

<p>こちらもAPIのエンドポイントは特にドキュメントがなかったのでswaggerから読む必要があります。</p>

<p>以下の場所に<code>swagger.json</code>が置いてあります</p>

<pre><code class="language-sh">$ swagger serve daemon-scheduler/generated/v1/swagger.json
</code></pre>

<h2 id="試す">試す</h2>

<p>※ 残念ながら試せたのはdaemon-schedulerのみです</p>

<h3 id="セットアップ">セットアップ</h3>

<p>Bloxが用意しているCloudFormationTemplateを使うとcluster-state-serviceとdaemon-schedulerが同時に動くようになっていますので同時にセットアップを行う形となります。</p>

<p>まずはBloxをAWSにデプロイします。</p>

<p><a href="https://github.com/blox/blox/tree/master/deploy#aws-installation">ドキュメント</a>に従ってやっていきます
今回は本番を想定してローカルではなくAWS上で動かします。</p>

<p><code>/tmp/blox_parameters.json</code>を用意します</p>

<p>EcsAmiIdは2016/12/07時点で最新の<a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_container_instance.html">ECS Optimized AMI</a>を使います。ちなみに東京リージョンです</p>

<pre><code class="language-json">[
  { &quot;ParameterKey&quot;: &quot;EcsAmiId&quot;, &quot;ParameterValue&quot;: &quot;ami-9cd57ffd&quot; },
  { &quot;ParameterKey&quot;: &quot;InstanceType&quot;, &quot;ParameterValue&quot;: &quot;t2.micro&quot; },
  { &quot;ParameterKey&quot;: &quot;KeyName&quot;, &quot;ParameterValue&quot;: &quot;my-keypair&quot; },
  { &quot;ParameterKey&quot;: &quot;EcsClusterName&quot;, &quot;ParameterValue&quot;: &quot;Blox&quot; },
  { &quot;ParameterKey&quot;: &quot;QueueName&quot;, &quot;ParameterValue&quot;: &quot;blox_queue&quot; },
  { &quot;ParameterKey&quot;: &quot;ApiStageName&quot;, &quot;ParameterValue&quot;: &quot;blox&quot; }
]
</code></pre>

<p>それではデプロイします。</p>

<p>AWSの認証情報は適宜用意しておいてください。</p>

<pre><code class="language-sh">$ git clone git@github.com:blox/blox.git
$ cd blox
$ aws --region ap-northeast-1 cloudformation create-stack \
      --stack-name BloxAws \
      --template-body file://./deploy/aws/conf/cloudformation_template.json \
      --capabilities CAPABILITY_NAMED_IAM \
      --parameters file:///tmp/blox_parameters.json
</code></pre>

<p>CloudFormation管理画面上でスタックのステータスがCREATE_COMPLETEになったらデプロイ完了です</p>

<p><img src="https://i.gyazo.com/52ad79c7fcee9719044fecadc351ddd9.png" alt="CloudFormation Status" /></p>

<p>Bloxのエンドポイントを取得します。</p>

<pre><code class="language-sh">$ aws --region ap-northeast-1 cloudformation describe-stacks \
      --stack-name BloxAws \
      --query 'Stacks[0].Outputs[0].OutputValue' \
      --output text
https://kiwozuwzpf.execute-api.ap-northeast-1.amazonaws.com/blox
</code></pre>

<p>BloxのAPIを使うには認証が必要です。</p>

<p>BloxはAPI Gatewayを経由してAWSのIAM認証が可能です。</p>

<p>お使いのIAM Userに必要な権限がアタッチされていない場合は<a href="https://github.com/blox/blox/tree/master/deploy#authentication">こちら</a>を参考に設定してください</p>

<p>認証にはAWS SignatureをサポートしているAPIクライアントの<a href="https://www.getpostman.com/">Postman</a>を使うと便利です</p>

<p><img src="https://i.gyazo.com/2a443a422e660c8a205cfab41191072b.png" alt="Authenticate with Postman" /></p>

<p>APIのテストとしてdaemon-schedulerのエンドポイントである<code>/v1/ping</code>を叩いてみます</p>

<p>無事<code>200 OK</code>が返ってきました</p>

<p><img src="https://i.gyazo.com/6e9d14a41b2bf427308879fea4e8f00b.png" alt="API Test" /></p>

<p>これでBloxのセットアップは完了です</p>

<h3 id="cluster-state-service-1">cluster-state-service</h3>

<p>Bloxが提供しているCloudFormationTemplateを読むと、cluster-state-serviceはELBと連携していないので、外部からのApiGateway経由ではアクセスできません。</p>

<p>おそらくクラスタ内部で扱うものだと思いますので今回は特に試しませんでした。</p>

<p>Internal ELBにも紐付いていないため、APIを使うとしたらBloxと同じタスク内で使うことになるかと思います。</p>

<h3 id="daemon-scheduler-1">daemon-scheduler</h3>

<p>まずはBloxクラスタとは別に任意のアプリケーションなどを動作させるためのクラスタを準備します。</p>

<p><a href="https://github.com/aws/amazon-ecs-cli">ecs-cli</a>を使うと楽です。</p>

<p>以下のようなyamlを用意します</p>

<p>検証用に用意しただけなので、どのようなコンテナでも構いません</p>

<pre><code class="language-yaml"># docker-compose.yml
version: '2'
services:
  web:
    image: &quot;nginx:alpine&quot;
    ports:
      - &quot;80:80&quot;
</code></pre>

<p>以下のコマンドでクラスタを作成します</p>

<pre><code class="language-sh">$ ecs-cli up --keypair my-keypair --capability-iam --size 1
</code></pre>

<p>クラスタが作成できたら、TaskDefinitionの登録と実行をします</p>

<pre><code class="language-sh">$ ecs-cli compose up
</code></pre>

<p>無事、クラスタ内でタスクが実行されました</p>

<p><img src="https://i.gyazo.com/d4b8ce66e850b182d73f773e286d89ae.png" alt="Setup ECS cluster" /></p>

<p>さて、それではdaemon-schedulerを触っていきます。</p>

<p>Bloxのリポジトリ内には<a href="https://github.com/blox/blox/tree/dev/deploy/demo-cli">APIを叩くための便利なクライアント</a>が用意されているのでそれを使います。</p>

<p>まずはEnvironmentを作成します</p>

<p>Environmentで定義するのは、どのクラスタでどのタスクを動かすか、です。</p>

<pre><code class="language-sh">$ ./blox-create-environment.py --apigateway
== Blox Demo CLI - Create Blox Environment ==

- Enter CloudFormation stack name: BloxAws
- Enter Blox environment name: my-environment
- Enter ECS cluster name: tsub-sandbox
- Enter ECS task definition arn: ecscompose-ecs-cli


HTTP Response Code: 200
{
  &quot;deploymentToken&quot;: &quot;e22fadc7-3bbd-4de4-b28b-ecafae2c3826&quot;,
  &quot;health&quot;: &quot;healthy&quot;,
  &quot;name&quot;: &quot;my-environment&quot;,
  &quot;instanceGroup&quot;: {
    &quot;cluster&quot;: &quot;arn:aws:ecs:ap-northeast-1:000000000001:cluster/tsub-sandbox&quot;
  }
}
</code></pre>

<p>そして、先ほど作ったEnvironmentを使ってDeploymentを作成します。</p>

<p>Deploymentを作ることで対象のクラスタで実際にタスクが実行され始めます。</p>

<pre><code class="language-sh">$ ./blox-create-deployment.py --apigateway
== Blox Demo CLI - Create Blox Deployment ==

- Enter CloudFormation stack name: BloxAws
- Enter Blox environment name: my-environment
- Enter Blox deployment token: e22fadc7-3bbd-4de4-b28b-ecafae2c3826


HTTP Response Code: 200
{
  &quot;status&quot;: &quot;pending&quot;,
  &quot;environmentName&quot;: &quot;tsub-environment&quot;,
  &quot;id&quot;: &quot;66fee44a-63c3-494e-aa34-476f14b4c4e3&quot;,
  &quot;failedInstances&quot;: [],
  &quot;taskDefinition&quot;: &quot;arn:aws:ecs:ap-northeast-1:000000000001:task-definition/ecscompose-ecs-cli:1&quot;
}
</code></pre>

<p>試しにコンテナインスタンスの数を増やしてみましょう。</p>

<p><img src="https://i.gyazo.com/8e1085117f65077e197cf4a13e3c3e12.png" alt="Increament cluster instance" /></p>

<p>新たに追加されたコンテナインスタンスでタスクが実行され始めました 👏</p>

<p><img src="https://i.gyazo.com/87c17323e02353dca7716ad07cbaa1ed.png" alt="daemon-scheduler DEMO" /></p>

<p>このように、特に何もしなくともコンテナインスタンスが追加されるたびにdaemon-schedulerが自動で対象のタスクを実行してくれるようになります。</p>

<h2 id="所感">所感</h2>

<p>まさにECSの不満な部分を解決する救世主が現れた感じですね。</p>

<p>まだまだドキュメントや利用例が充実していないため、今回は手探りで使ってみたので間違ってるところなどあればご指摘いただければと思います。</p>

<p>特に使ってみた感触として、今回はBloxとアプリケーションは別々のクラスタで動かしましたが、Bloxを動かすクラスタはアプリケーションと同じクラスタを想定しているような気がしていて、その辺り引っかかっています。</p>

<p>今後の開発に期待ですね 😄</p>
      
      
      
    </article>
    


  </main>
  
  <nav class="pagination-single">
    
      <span class="previous">&larr; <a href="https://blog.tsub.me/post/created-blog-by-hugo/" rel="prev">はてなブログからHugo on Github Pagesに移行しました</a></span>
    
    
      <span class="next"><a href="https://blog.tsub.me/post/how-i-collect-information/" rel="next">ぼくの情報収集方法</a> &rarr;</span>
    
  </nav>


  
  <footer role="contentinfo">
    <div style="text-align:center;">
      <img src="/images/profile.jpg" width="64" height="64"><br>
      Copyright 2016 tsub
    </div>
  </footer>


</div>

<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-63212158-2', 'auto');
	ga('send', 'pageview');
</script>

</body>
</html>

